"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = (x) => {
  if (typeof require !== "undefined")
    return require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
};

// src/index.ts
var _path = require('path');

// src/context.ts

var _debug = require('debug'); var _debug2 = _interopRequireDefault(_debug);
var _chokidar = require('chokidar'); var _chokidar2 = _interopRequireDefault(_chokidar);

// src/utils.ts

var _minimatch = require('minimatch'); var _minimatch2 = _interopRequireDefault(_minimatch);

// src/helpers/libraryResolver.ts
var _fs = require('fs'); var _fs2 = _interopRequireDefault(_fs);


var debug = _debug2.default.call(void 0, "vite-plugin-components:helper:library");
function tryLoadVeturTags(name) {
  var _a;
  try {
    const pkgPath = __require.resolve(`${name}/package.json`);
    if (!pkgPath)
      return;
    const pkg = JSON.parse(_fs2.default.readFileSync(pkgPath, "utf-8"));
    const tagsPath = (_a = pkg == null ? void 0 : pkg.vetur) == null ? void 0 : _a.tags;
    if (!tagsPath)
      return;
    const tags = JSON.parse(_fs2.default.readFileSync(_path.join.call(void 0, _path.dirname.call(void 0, pkgPath), tagsPath), "utf-8"));
    return Object.keys(tags).map((i) => camelCase(i));
  } catch (e) {
    console.error(e);
  }
}
function LibraryResolver(options) {
  const {
    name: libraryName,
    entries = tryLoadVeturTags(options.name),
    prefix = ""
  } = options;
  if (!entries) {
    console.warn(`[vite-plugin-components] Failed to load Vetur tags from library "${libraryName}"`);
    return () => {
    };
  }
  debug(entries);
  const prefixKebab = kebabCase(prefix);
  const kebabEntries = entries.map((name) => ({name, kebab: kebabCase(name)}));
  return (name) => {
    const kebab = kebabCase(name);
    let componentName = kebab;
    if (prefixKebab) {
      if (!kebab.startsWith(`${prefixKebab}-`))
        return;
      componentName = kebab.slice(prefixKebab.length + 1);
    }
    for (const entry of kebabEntries) {
      if (entry.kebab === componentName)
        return {path: libraryName, importName: entry.name};
    }
  };
}

// src/constants.ts
var defaultOptions = {
  dirs: "src/components",
  extensions: "vue",
  transformer: "vue3",
  deep: true,
  globalComponentsDeclaration: false,
  directoryAsNamespace: false,
  globalNamespaces: [],
  libraries: [],
  customLoaderMatcher: () => false,
  customComponentResolvers: [],
  importPathTransform: (v) => v
};

// src/utils.ts
function slash(str) {
  return str.replace(/\\/g, "/");
}
function pascalCase(str) {
  return capitalize(camelCase(str));
}
function camelCase(str) {
  return str.replace(/-(\w)/g, (_, c) => c ? c.toUpperCase() : "");
}
function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, " $1").trim();
  return result.split(" ").join("-").toLowerCase();
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function toArray(arr) {
  if (Array.isArray(arr))
    return arr;
  return [arr];
}
function parseId(id) {
  const index = id.indexOf("?");
  if (index < 0) {
    return {path: id, query: {}};
  } else {
    const query = Object.fromEntries(new URLSearchParams(id.slice(index)));
    return {
      path: id.slice(0, index),
      query
    };
  }
}
function isEmpty(value) {
  if (!value || value === null || value === void 0 || Array.isArray(value) && Object.keys(value).length <= 0)
    return true;
  else
    return false;
}
function matchGlobs(filepath, globs) {
  for (const glob of globs) {
    if (_minimatch2.default.call(void 0, slash(filepath), glob))
      return true;
  }
  return false;
}
function stringifyImport(info) {
  if (typeof info === "string")
    return `import '${info}'`;
  if (!info.name)
    return `import '${info.path}'`;
  else if (info.importName)
    return `import { ${info.importName} as ${info.name} } from '${info.path}'`;
  else
    return `import ${info.name} from '${info.path}'`;
}
function stringifyComponentImport({name, path, importName, sideEffects}, ctx) {
  if (ctx.options.importPathTransform) {
    const result = ctx.options.importPathTransform(path);
    if (result != null)
      path = result;
  }
  const imports = [
    stringifyImport({name, path, importName})
  ];
  if (sideEffects)
    toArray(sideEffects).forEach((i) => imports.push(stringifyImport(i)));
  return imports.join("\n");
}
function resolveOptions(options, viteConfig) {
  const resolved = Object.assign({}, defaultOptions, options);
  resolved.libraries = toArray(resolved.libraries).map((i) => typeof i === "string" ? {name: i} : i);
  resolved.customComponentResolvers = toArray(resolved.customComponentResolvers);
  resolved.customComponentResolvers.push(...resolved.libraries.map((lib) => LibraryResolver(lib)));
  resolved.extensions = toArray(resolved.extensions);
  const extsGlob = resolved.extensions.length === 1 ? resolved.extensions : `{${resolved.extensions.join(",")}}`;
  resolved.dirs = toArray(resolved.dirs);
  resolved.resolvedDirs = resolved.dirs.map((i) => slash(_path.resolve.call(void 0, viteConfig.root, i)));
  resolved.globs = resolved.dirs.map((i) => resolved.deep ? slash(_path.join.call(void 0, i, `**/*.${extsGlob}`)) : slash(_path.join.call(void 0, i, `*.${extsGlob}`)));
  if (!resolved.extensions.length)
    throw new Error("[vite-plugin-components] extensions are required to search for components");
  return resolved;
}
function getNameFromFilePath(filePath, options) {
  const {resolvedDirs, directoryAsNamespace, globalNamespaces} = options;
  const parsedFilePath = _path.parse.call(void 0, slash(filePath));
  let strippedPath = "";
  for (const dir of resolvedDirs) {
    if (parsedFilePath.dir.startsWith(dir)) {
      strippedPath = parsedFilePath.dir.slice(dir.length);
      break;
    }
  }
  let folders = strippedPath.slice(1).split("/").filter(Boolean);
  let filename = parsedFilePath.name;
  if (filename === "index" && !directoryAsNamespace) {
    filename = `${folders.slice(-1)[0]}`;
    return filename;
  }
  if (directoryAsNamespace) {
    if (globalNamespaces.some((name) => folders.includes(name)))
      folders = folders.filter((f) => !globalNamespaces.includes(f));
    if (filename.toLowerCase() === "index")
      filename = "";
    if (!isEmpty(folders)) {
      filename = [...folders, filename].filter(Boolean).join("-");
    }
    return filename;
  }
  return filename;
}
function resolveAlias(filepath, alias = []) {
  const result = filepath;
  if (Array.isArray(alias)) {
    for (const {find, replacement} of alias)
      result.replace(find, replacement);
  }
  return result;
}

// src/fs/glob.ts
var _fastglob = require('fast-glob'); var _fastglob2 = _interopRequireDefault(_fastglob);

var debug2 = _debug2.default.call(void 0, "vite-plugin-components:glob");
function searchComponents(ctx) {
  var _a;
  debug2(`started with: [${ctx.options.globs.join(", ")}]`);
  const root = ctx.root;
  const files = _fastglob2.default.sync(ctx.options.globs, {
    ignore: ["node_modules"],
    onlyFiles: true,
    cwd: root,
    absolute: true
  });
  if (!files.length && !((_a = ctx.options.customComponentResolvers) == null ? void 0 : _a.length))
    console.warn("[vite-plugin-components] no components found");
  debug2(`${files.length} components found.`);
  ctx.addComponents(files);
}

// src/context.ts
var debug3 = {
  components: _debug2.default.call(void 0, "vite-plugin-components:context:components"),
  search: _debug2.default.call(void 0, "vite-plugin-components:context:search"),
  hmr: _debug2.default.call(void 0, "vite-plugin-components:context:hmr")
};
var Context = class {
  constructor(options, viteConfig) {
    this.viteConfig = viteConfig;
    this._componentPaths = new Set();
    this._componentNameMap = {};
    this._componentUsageMap = {};
    this._searched = false;
    this.options = resolveOptions(options, viteConfig);
    const {globs, dirs} = this.options;
    if (viteConfig.command === "serve") {
      _chokidar2.default.watch(dirs, {ignoreInitial: true, cwd: this.root}).on("unlink", (path) => {
        if (matchGlobs(path, globs)) {
          this.removeComponents(path);
          this.onUpdate(path);
        }
      }).on("add", (path) => {
        if (matchGlobs(path, globs)) {
          this.addComponents(path);
          this.onUpdate(path);
        }
      });
    }
  }
  get root() {
    return this.viteConfig.root;
  }
  setServer(server) {
    this._server = server;
  }
  updateUsageMap(path, paths) {
    if (!this._componentUsageMap[path])
      this._componentUsageMap[path] = new Set();
    paths.forEach((p) => {
      this._componentUsageMap[path].add(p);
    });
  }
  addComponents(paths) {
    debug3.components("add", paths);
    const size = this._componentPaths.size;
    toArray(paths).forEach((p) => this._componentPaths.add(p));
    if (this._componentPaths.size !== size) {
      this.updateComponentNameMap();
      return true;
    }
    return false;
  }
  removeComponents(paths) {
    debug3.components("remove", paths);
    const size = this._componentPaths.size;
    toArray(paths).forEach((p) => this._componentPaths.delete(p));
    if (this._componentPaths.size !== size) {
      this.updateComponentNameMap();
      return true;
    }
    return false;
  }
  onUpdate(path) {
    if (!this._server)
      return;
    const payload = {
      type: "update",
      updates: []
    };
    const timestamp = +new Date();
    const name = pascalCase(getNameFromFilePath(path, this.options));
    Object.entries(this._componentUsageMap).forEach(([key, values]) => {
      if (values.has(name)) {
        const r = `/${slash(_path.relative.call(void 0, this.viteConfig.root, key))}`;
        payload.updates.push({
          acceptedPath: r,
          path: r,
          timestamp,
          type: "js-update"
        });
      }
    });
    if (payload.updates.length)
      this._server.ws.send(payload);
  }
  updateComponentNameMap() {
    this._componentNameMap = {};
    Array.from(this._componentPaths).forEach((path) => {
      const name = pascalCase(getNameFromFilePath(path, this.options));
      if (this._componentNameMap[name]) {
        console.warn(`[vite-plugin-components] component "${name}"(${path}) has naming conflicts with other components, ignored.`);
        return;
      }
      this._componentNameMap[name] = {
        name,
        path: `/${this.relative(path)}`
      };
    });
  }
  findComponent(name, excludePaths = []) {
    const info = this._componentNameMap[name];
    if (info && !excludePaths.includes(info.path) && !excludePaths.includes(info.path.slice(1)))
      return info;
    for (const resolver of this.options.customComponentResolvers) {
      const result = resolver(name);
      if (result) {
        if (typeof result === "string") {
          return {
            name,
            path: result
          };
        } else {
          return __spreadValues({
            name
          }, result);
        }
      }
    }
    return void 0;
  }
  findComponents(names, excludePaths = []) {
    return names.map((name) => this.findComponent(name, excludePaths)).filter(Boolean);
  }
  normalizePath(path) {
    var _a, _b, _c;
    return resolveAlias(path, ((_b = (_a = this.viteConfig) == null ? void 0 : _a.resolve) == null ? void 0 : _b.alias) || ((_c = this.viteConfig) == null ? void 0 : _c.alias) || []);
  }
  relative(path) {
    if (path.startsWith("/") && !path.startsWith(this.root))
      return slash(path.slice(1));
    return slash(_path.relative.call(void 0, this.root, path));
  }
  searchGlob() {
    if (this._searched)
      return;
    searchComponents(this);
    debug3.search(this._componentNameMap);
    this._searched = true;
  }
  get componentNameMap() {
    return this._componentNameMap;
  }
};

// src/transforms/vue3.ts

var _magicstring = require('magic-string'); var _magicstring2 = _interopRequireDefault(_magicstring);
var debug4 = _debug2.default.call(void 0, "vite-plugin-components:transform:vue3");
function Vue3Transformer(ctx) {
  return (code, id, path, query) => {
    if (!(path.endsWith(".vue") || ctx.options.customLoaderMatcher(id)))
      return null;
    ctx.searchGlob();
    const sfcPath = ctx.normalizePath(path);
    debug4(sfcPath);
    const head = [];
    let no = 0;
    const componentPaths = [];
    const s = new (0, _magicstring2.default)(code);
    for (const match of code.matchAll(/_resolveComponent\("(.+?)"\)/g)) {
      const matchedName = match[1];
      if (match.index != null && matchedName && !matchedName.startsWith("_")) {
        const start = match.index;
        const end = start + match[0].length;
        debug4(`| ${matchedName}`);
        const name = pascalCase(matchedName);
        componentPaths.push(name);
        const component = ctx.findComponent(name, [sfcPath]);
        if (component) {
          const var_name = `__vite_components_${no}`;
          head.push(stringifyComponentImport(__spreadProps(__spreadValues({}, component), {name: var_name}), ctx));
          no += 1;
          s.overwrite(start, end, var_name);
        }
      }
    }
    debug4(`^ (${no})`);
    ctx.updateUsageMap(sfcPath, componentPaths);
    s.prepend(`${head.join("\n")}
`);
    const result = {code: s.toString()};
    if (ctx.viteConfig.build.sourcemap)
      result.map = s.generateMap({hires: true});
    return result;
  };
}

// src/transforms/vue2.ts


var debug5 = _debug2.default.call(void 0, "vite-plugin-components:transform:vue2");
function Vue2Transformer(ctx) {
  return (code, id, path, query) => {
    if (!(path.endsWith(".vue") || ctx.options.customLoaderMatcher(id)))
      return null;
    ctx.searchGlob();
    const sfcPath = ctx.normalizePath(path);
    debug5(sfcPath);
    const head = [];
    let no = 0;
    const componentPaths = [];
    const s = new (0, _magicstring2.default)(code);
    for (const match of code.matchAll(/_c\(['"](.+?)["']([,)])/g)) {
      const [full, matchStr, append] = match;
      if (match.index != null && matchStr && !matchStr.startsWith("_")) {
        const start = match.index;
        const end = start + full.length;
        debug5(`| ${matchStr}`);
        const name = pascalCase(matchStr);
        componentPaths.push(name);
        const component = ctx.findComponent(name, [sfcPath]);
        if (component) {
          const var_name = `__vite_components_${no}`;
          head.push(stringifyComponentImport(__spreadProps(__spreadValues({}, component), {name: var_name}), ctx));
          no += 1;
          s.overwrite(start, end, `_c(${var_name}${append}`);
        }
      }
    }
    debug5(`^ (${no})`);
    ctx.updateUsageMap(sfcPath, componentPaths);
    s.prepend(`${head.join("\n")}
`);
    const result = {code: s.toString()};
    if (ctx.viteConfig.build.sourcemap)
      result.map = s.generateMap({hires: true});
    return result;
  };
}

// src/declaration.ts

var _promises = require('fs/promises'); var _promises2 = _interopRequireDefault(_promises);
async function generateDeclaration(ctx, root, filepath) {
  const lines = Object.values(ctx.componentNameMap).map(({path, name, importName}) => {
    const related = slash(path).startsWith("/") ? `./${_path.relative.call(void 0, _path.dirname.call(void 0, filepath), _path.resolve.call(void 0, root, path.slice(1)))}` : path;
    let entry = `${name}: typeof import('${slash(related)}')`;
    if (importName)
      entry += `['${importName}']`;
    else
      entry += "['default']";
    return entry;
  });
  const code = `// generated by vite-plugin-components
// read more https://github.com/vuejs/vue-next/pull/3399

declare module 'vue' {
  export interface GlobalComponents {
    ${lines.join("\n    ")}
  }
}

export { }
`;
  await _promises2.default.writeFile(filepath, code, "utf-8");
}

// src/resolvers/antdv.ts
var AntDesignVueResolver = () => (name) => {
  if (name.match(/^A[A-Z]/))
    return {importName: name.slice(1), path: "ant-design-vue/es"};
};

// src/resolvers/element-plus.ts
var ElementPlusResolver = (options = {}) => (name) => {
  const {importStyle = true} = options;
  if (name.startsWith("El")) {
    const partialName = name[2].toLowerCase() + name.substring(3).replace(/[A-Z]/g, (l) => `-${l.toLowerCase()}`);
    return {
      path: `element-plus/es/el-${partialName}`,
      sideEffects: importStyle ? `element-plus/packages/theme-chalk/src/${partialName}.scss` : void 0
    };
  }
};

// src/resolvers/headlessUi.ts
var components = [
  "Dialog",
  "DialogDescription",
  "DialogOverlay",
  "DialogTitle",
  "Disclosure",
  "DisclosureButton",
  "DisclosurePanel",
  "FocusTrap",
  "Listbox",
  "ListboxButton",
  "ListboxLabel",
  "ListboxOption",
  "ListboxOptions",
  "Menu",
  "MenuButton",
  "MenuItem",
  "MenuItems",
  "Popover",
  "PopoverButton",
  "PopoverGroup",
  "PopoverOverlay",
  "PopoverPanel",
  "Portal",
  "PortalGroup",
  "RadioGroup",
  "RadioGroupDescription",
  "RadioGroupLabel",
  "RadioGroupOption",
  "Switch",
  "SwitchDescription",
  "SwitchGroup",
  "SwitchLabel",
  "TransitionChild",
  "TransitionRoot"
];
var HeadlessUiResolver = () => (name) => {
  if (components.includes(name))
    return {importName: name, path: "@headlessui/vue"};
};

// src/resolvers/vant.ts
var VantResolver = (options = {}) => (name) => {
  const {importStyle = true} = options;
  if (name.startsWith("Van")) {
    const partialName = name.slice(3);
    return {
      importName: partialName,
      path: "vant/es",
      sideEffects: importStyle ? `vant/es/${kebabCase(partialName)}/style` : void 0
    };
  }
};

// src/resolvers/vuetify.ts
var VuetifyResolver = () => (name) => {
  if (name.match(/^V[A-Z]/))
    return {importName: name, path: "vuetify/lib"};
};

// src/resolvers/vueuse.ts
var components2;
var VueUseComponentsResolver = () => (name) => {
  if (!components2) {
    try {
      const indexesJson = __require("@vueuse/core/indexes.json");
      components2 = indexesJson.functions.filter((i) => i.component && i.name).map(({name: name2}) => name2[0].toUpperCase() + name2.slice(1));
    } catch (error) {
      components2 = [];
    }
  }
  if (components2 && components2.includes(name))
    return {importName: name, path: "@vueuse/components"};
};

// src/index.ts
function VitePluginComponents(options = {}) {
  let ctx;
  let transformer;
  return {
    name: "vite-plugin-components",
    enforce: "post",
    configResolved(config) {
      if (config.plugins.find((i) => i.name === "vite-plugin-vue2"))
        options.transformer = options.transformer || "vue2";
      ctx = new Context(options, config);
      transformer = ctx.options.transformer === "vue2" ? Vue2Transformer(ctx) : Vue3Transformer(ctx);
      if (options.globalComponentsDeclaration) {
        ctx.searchGlob();
        const path = _path.resolve.call(void 0, config.root, typeof options.globalComponentsDeclaration === "string" ? options.globalComponentsDeclaration : "components.d.ts");
        generateDeclaration(ctx, config.root, path);
      }
    },
    configureServer(server) {
      ctx.setServer(server);
    },
    transform(code, id) {
      const {path, query} = parseId(id);
      return transformer(code, id, path, query);
    }
  };
}
var src_default = VitePluginComponents;













exports.AntDesignVueResolver = AntDesignVueResolver; exports.ElementPlusResolver = ElementPlusResolver; exports.HeadlessUiResolver = HeadlessUiResolver; exports.LibraryResolver = LibraryResolver; exports.VantResolver = VantResolver; exports.VueUseComponentsResolver = VueUseComponentsResolver; exports.VuetifyResolver = VuetifyResolver; exports.camelCase = camelCase; exports.default = src_default; exports.kebabCase = kebabCase; exports.pascalCase = pascalCase; exports.tryLoadVeturTags = tryLoadVeturTags;
